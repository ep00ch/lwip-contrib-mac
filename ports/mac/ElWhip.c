/*  ElWhip.c *   * *  Created by Eric Pooch on 1/26/14. *  Copyright 2014 __MyCompanyName__. All rights reserved. * */#include <Values.h>#include <Types.h>#include <QuickDraw.h>#include <Fonts.h>#include <Events.h>#include <Windows.h>#include <Menus.h>#include <Dialogs.h>#include <Files.h>#include <Desk.h>#include <ToolUtils.h>#include <Memory.h>#include <SegLoad.h>#include <OSUtils.h>#include <OSEvents.h>#include <Traps.h>#include "arch/macos_debug.h"#include <string.h>#include <stdlib.h>#include "ElWhip.h"#include "test.h"/* GMac is used to hold the result of a SysEnvirons call. This makes   it convenient for any routine to check the environment. */SysEnvRec	gMac;				/* set up by Initialize *//* GHasWaitNextEvent is set at startup, and tells whether the WaitNextEvent   trap is available. If it is false, we know that we must call GetNextEvent. *///Boolean		gHasWaitNextEvent;	/* set up by Initialize *//* GInBackground is maintained by our osEvent handling routines. Any part of   the program can check it to find out if it is currently in the background. */Boolean		gInBackground;		/* maintained by Initialize and DoEvent *//* Here are declarations for all of the C routines. In MPW 3.0 we can use   actual prototypes for parameter type checking. */void EventLoop( void );void DoEvent( EventRecord *event );void DoMenuCommand( long menuResult );void MemoryInit( void );void MacintoshInit( void );void Restart(void);void Terminate( void );void GetTERect(WindowPtr window, Rect *teRect);Boolean TrapAvailable( short tNumber, TrapType tType );void AlertUser( void );/* Define HiWrd and LoWrd macros for efficiency. */#define HiWrd(aLong)	(((aLong) >> 16) & 0xFFFF)#define LoWrd(aLong)	((aLong) & 0xFFFF)/* This routine is part of the MPW runtime library. This external   reference to it is done so that we can unload its segment, %A5Init. */extern void _DataInit();int main(void){	OSErr error = 0;	FILE *fildes;	char buff[255];		UnloadSeg((Ptr) _DataInit);		MemoryInit();	MacintoshInit();					/* initialize the program */	test_init();	EventLoop();					/* call the main event loop */	return 0;}/*	Get events forever, and handle them by calling DoEvent.	Get the events by calling WaitNextEvent, if it's available, otherwise	by calling GetNextEvent. Also call AdjustCursor each time through the loop. */#pragma segment Mainvoid EventLoop(){	Boolean		gotEvent;	EventRecord	event;	RgnHandle	cursorRgn;	do {		/* use WNE if it is available */		//if ( gHasWaitNextEvent )		//{		//	gotEvent = WaitNextEvent(everyEvent, &event, MAXLONG, cursorRgn);		//} else		//{			SystemTask();			gotEvent = GetNextEvent(everyEvent, &event);		//}		if ( gotEvent )		{			/* Handle the event */			DoEvent(&event);		}				test_poll();	} while ( true );	/* loop forever; we quit via ExitToShell */} /*EventLoop*//* Do the right thing for an event. Determine what kind of event it is, and call the appropriate routines. */void DoEvent( EventRecord *event ){	short		part, err;	WindowPtr	window;	Boolean		hit;	char		key;	switch ( event->what ) {		case mouseDown:			part = FindWindow(event->where, &window);			switch ( part ) {				case inMenuBar:				/* process a mouse menu command (if any) */					DoMenuCommand(MenuSelect(event->where));					break;				case inSysWindow:			/* let the system handle the mouseDown */					SystemClick(event, window);					break;			}			break;		case keyDown:		case autoKey:						/* check for menukey equivalents */			key = event->message & charCodeMask;			if ( event->modifiers & cmdKey )			/* Command key down */			{				if ( event->what == keyDown ) {					DoMenuCommand(MenuKey(key));				}			}			break;		case kOSEvent:		/*	1.02 - must BitAND with 0x0FF to get only low byte */			switch ((event->message >> 24) & 0x0FF) {		/* high byte of message */				case kSuspendResumeMessage:		/* suspend/resume is also an activate/deactivate */					gInBackground = (event->message & kResumeMask) == 0;					//DoActivate(FrontWindow(), !gInBackground);					break;			}			break;	}} /*DoEvent*//*	This is called when an item is chosen from the menu bar (after calling	MenuSelect or MenuKey). It performs the right operation for each command.	It is good to have both the result of MenuSelect and MenuKey go to	one routine like this to keep everything organized. */void DoMenuCommand(long menuResult){	short		menuID = HiWord(menuResult);		/* the resource ID of the selected menu */	short		menuItem = LoWord(menuResult);			/* the item number of the selected menu */	short		itemHit;	Str255		daName;	short		daRefNum;	Boolean		handledByDA;	switch ( menuID ) {		case mApple:			switch ( menuItem ) {				case iAbout:		/* bring up alert for About */					itemHit = Alert(rAboutAlert, nil);					break;				default:			/* all non-About items in this menu are DAs */					/* type Str255 is an array in MPW 3 */					GetItem(GetMHandle(mApple), menuItem, daName);					daRefNum = OpenDeskAcc(daName);					break;			}			break;		case mFile:			switch ( menuItem ) {				case iQuit:					Terminate();					break;			}			break;	}	HiliteMenu(0);					/* unhighlight what MenuSelect (or MenuKey) hilited */} /*DoMenuCommand*/#pragma segment LWUPDNvoid MemoryInit(){	/*	If you have stack requirements that differ from the default,		then you could use SetApplLimit to increase StackSpace at 		this point, before calling MaxApplZone. */	MaxApplZone();					/* expand the heap so code segments load at the top */		//LWIP_DEBUGF(LWIP_DBG_LEVEL_WARNING, ("App Limit: %lu \n", (long)GetApplLimit() ));	//LWIP_DEBUGF(LWIP_DBG_LEVEL_WARNING, ("Free Memory: %lu \n", (long)FreeMem() ));}/*	Set up the whole world, including global variables, Toolbox managers,	and menus.  */void MacintoshInit(){	Handle		menuBar;	WindowPtr	window;	long		total, contig;	EventRecord event;	short		count;			gInBackground = false;		InitGraf((Ptr) &qd.thePort);	InitFonts();	InitWindows();	InitMenus();	InitDialogs(nil);	InitCursor();	/*	Allow the default button of our alert be outlined. */	for (count = 1; count <= 3; count++)		EventAvail(everyEvent, &event);	 	SysEnvirons(kSysEnvironsVersion, &gMac);		/* Make sure that the machine has at least 128K ROMs. If it doesn't, exit. */	//if (gMac.machineType < 0) AlertUser();		/*	1.02 - Move TrapAvailable call to after SysEnvirons so that we can tell		in TrapAvailable if a tool trap value is out of range. *///	gHasWaitNextEvent = TrapAvailable(_WaitNextEvent, ToolTrap);	 //	if ((long) GetApplLimit() - (long) ApplicZone() < kMinHeap) AlertUser();		/* ZeroScrap(); */	//PurgeSpace(&total, &contig);	//if (total < kMinSpace) AlertUser();	menuBar = GetNewMBar(rMenuBar);			/* read menus into menu bar */	if ( menuBar == nil ) AlertUser();	SetMenuBar(menuBar);					/* install menus */	DisposHandle(menuBar);	AddResMenu(GetMHandle(mApple), 'DRVR');	/* add DA names to Apple menu */	DrawMenuBar();	#ifdef MACOS_BROWSER	BrowserInit();#endif} /*Initialize*/#pragma segment Mainvoid Terminate(){	test_stop();	ExitToShell();							/* exit if no cancellation */} /*Terminate*/void Restart(void){	test_restart();	//UnloadSeg((Ptr) MacintoshInit);}/* Return a rectangle that is inset from the portRect by the size of	the scrollbars and a little extra margin. */void GetTERect(WindowPtr window, Rect *teRect){	*teRect = window->portRect;	InsetRect(teRect, kTextMargin, kTextMargin);	/* adjust for margin */	teRect->bottom = teRect->bottom - kScrollWidth;		/* and for the scrollbars */	teRect->right = teRect->right - kScrollWidth;} /*GetTERect*//* Check to see if a window belongs to a desk accessory. */Boolean IsDAWindow(WindowPtr window){	if ( window == nil )		return false;	else	/* DA windows have negative windowKinds */		return ((WindowPeek) window)->windowKind < 0;} /*IsDAWindow*/void AlertUser(){	short		itemHit;	SetCursor(&qd.arrow);	itemHit = Alert(rUserAlert, nil);	ExitToShell();} /* AlertUser *//*	Check to see if a given trap is implemented. This is only used by the	Initialize routine in this program, so we put it in the Initialize segment.	The recommended approach to see if a trap is implemented is to see if	the address of the trap routine is the same as the address of the	Unimplemented trap. */#pragma segment LWUPDNBoolean TrapAvailable(short tNumber, TrapType tType){	if ( ( tType == ToolTrap ) &&		( gMac.machineType > envMachUnknown ) &&		( gMac.machineType < envMacII ) ) {		/* it's a 512KE, Plus, or SE */		tNumber = tNumber & 0x03FF;		if ( tNumber > 0x01FF )					/* which means the tool traps */			tNumber = _Unimplemented;			/* only go to 0x01FF */	}	return NGetTrapAddress(tNumber, tType) != GetTrapAddress(_Unimplemented);} /*TrapAvailable*/